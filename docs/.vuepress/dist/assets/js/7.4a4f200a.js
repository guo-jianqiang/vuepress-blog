(window.webpackJsonp=window.webpackJsonp||[]).push([[7],{359:function(t,s,a){"use strict";a.r(s);var e=a(42),v=Object(e.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"typescript"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#typescript"}},[t._v("#")]),t._v(" typescript")]),t._v(" "),a("p",[t._v("语言会影响人的思维方式，对于前端工程师来说，使用 typescript 开发无疑就是在尝试换一种思维方式做事情")]),t._v(" "),a("h3",{attrs:{id:"ts-怎么影响了我的思考方式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#ts-怎么影响了我的思考方式"}},[t._v("#")]),t._v(" TS 怎么影响了我的思考方式")]),t._v(" "),a("p",[t._v("对前端开发者来说，TS 能强化了「面向接口编程」这一理念。我们知道稍微复杂一点的程序都离不开不同模块间的配合，不同模块的功能理应是更为清晰的，TS 能帮我们梳理清不同的接口")]),t._v(" "),a("h3",{attrs:{id:"明确的模块抽象过程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#明确的模块抽象过程"}},[t._v("#")]),t._v(" 明确的模块抽象过程")]),t._v(" "),a("p",[t._v("TS 对我的思考方式的影响之一在于，我现在会把考虑抽象和拓展看作写一个模块前的必备环节了。当然一个好的开发者用任何语言写程序，考虑抽象和拓展都会是一个必备环节，不过如果你在日常生活中使用过清单，你就会明白 TS 通过接口将这种抽象明确为具体的内容的意义所在了，任何没有被明确的内容，其实都有点像是可选的内容，往往就容易被忽略。")]),t._v(" "),a("p",[t._v("举例来说，比如说我们用 TS 定义一个函数，TS 会要求我们对函数的参数及返回值有一个明确的定义，简单的定义一些类型，却能帮助我们定位函数的作用，比如说我们设置其返回值类型为 "),a("code",[t._v("void")]),t._v(" ，就明确的表明了我们想利用这个函数的副作用；")]),t._v(" "),a("p",[t._v("把抽象明确下来，对后续代码的修改也非常有意义，我们不用再担心忘记了之前是怎么构想的呢，对多人协作的团队来说，这一点也许更为重要")]),t._v(" "),a("h4",{attrs:{id:"更自信的写代码"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#更自信的写代码"}},[t._v("#")]),t._v(" 更自信的写代码")]),t._v(" "),a("p",[t._v("TS 还能让我更自信的写前端代码，这种自信来自 TS 可以帮我们避免很多可能由于自己的忽略造成的 bug。实际上，关于 TS 辅助避免 bug 方面存在专门的研究，表明使用 TS 进行静态类型检查能帮我们至少减少 15% 以上的 bug。")]),t._v(" "),a("p",[t._v("可以举一个例子来说明，TS 是怎么给我带来这种自信的。")]),t._v(" "),a("div",{staticClass:"language-javascript extra-class"},[a("pre",{pre:!0,attrs:{class:"language-javascript"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" a "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" document"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("getElementById")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"a"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),a("p",[t._v("对我自己来说，使用 TS 之前，我忽略了"),a("code",[t._v("document.getElementById")]),t._v("的返回值还可能是 "),a("code",[t._v("null")]),t._v("，这种不经意的忽略也许在未来就会造成一个意想不到的 bug。")]),t._v(" "),a("p",[t._v("使用 TS，在编辑器中就会明确的提醒我们 "),a("code",[t._v("a")]),t._v(" 的值可能为 "),a("code",[t._v("null")])]),t._v(" "),a("p",[t._v("下面这条语句，大家都很熟悉，是 DOM 提供依据 id 获取元素的方法")]),t._v(" "),a("p",[a("img",{attrs:{src:"/assets/img/typescript/1602643988052.jpg",alt:""}})]),t._v(" "),a("p",[t._v("我们并不一定要处理值 "),a("code",[t._v("null")]),t._v(" 的情况，使用 "),a("code",[t._v("const a = document.getElementById('id')!")]),t._v("可以明确告诉 TS ，它不会是 "),a("code",[t._v("null")]),t._v("，不过至少，这时候我们清楚的知道自己想做什么")]),t._v(" "),a("h4",{attrs:{id:"使用-ts-的过程就是一种学习的过程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#使用-ts-的过程就是一种学习的过程"}},[t._v("#")]),t._v(" 使用 TS 的过程就是一种学习的过程")]),t._v(" "),a("p",[t._v("使用 TS 后，感觉自己通过浏览器查文档的时间明显少了很多。无论是库还是原生的 js 或者 nodejs，甚至是自己团队其它成员定义的类型。结合 编辑器 （Vscode、webStorm），会有非常智能的提醒，也可以很方便看到相应的接口的确切定义。使用的过程就是在加深理解的过程，确实「面向接口编程」天然和静态类型更为亲密。")]),t._v(" "),a("p",[t._v("比如说，我们使用 Table这个组件，编辑器中会有下面这类提醒：")]),t._v(" "),a("p",[a("img",{attrs:{src:"/assets/img/typescript/WX20201014-105858@2x.png",alt:""}})]),t._v(" "),a("p",[t._v("不用去查文档，我们就能看到其提供的 API。 如果我们去看这个库的源文件会发现，能有提醒的原因在于存在下面这样的定义")]),t._v(" "),a("p",[a("img",{attrs:{src:"/assets/img/typescript/WX20201014-110058@2x.png",alt:""}})]),t._v(" "),a("p",[t._v("这种提醒无疑能增强开发的效率，虽然定义类型在早期会花费一定的时间，但是对于一个长期维护的比较大型的项目，使用 TS 非常值得。")])])}),[],!1,null,null,null);s.default=v.exports}}]);