<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>枚举 | a litter bug blog</title>
    <meta name="generator" content="VuePress 1.6.0">
    
    <meta name="description" content="Just playing around">
    <link rel="preload" href="/assets/css/0.styles.48f01dbf.css" as="style"><link rel="preload" href="/assets/js/app.05721dd8.js" as="script"><link rel="preload" href="/assets/js/2.49c8bc2a.js" as="script"><link rel="preload" href="/assets/js/14.3bc65c2a.js" as="script"><link rel="prefetch" href="/assets/js/10.7c51828b.js"><link rel="prefetch" href="/assets/js/11.90d001e5.js"><link rel="prefetch" href="/assets/js/12.3e8d926b.js"><link rel="prefetch" href="/assets/js/13.22706af1.js"><link rel="prefetch" href="/assets/js/15.0aca9f44.js"><link rel="prefetch" href="/assets/js/16.7df3d92c.js"><link rel="prefetch" href="/assets/js/17.be026028.js"><link rel="prefetch" href="/assets/js/18.b6e30a63.js"><link rel="prefetch" href="/assets/js/19.e7c0b238.js"><link rel="prefetch" href="/assets/js/20.3c7702fa.js"><link rel="prefetch" href="/assets/js/21.84f7d77b.js"><link rel="prefetch" href="/assets/js/22.67a7c91d.js"><link rel="prefetch" href="/assets/js/23.fcedea07.js"><link rel="prefetch" href="/assets/js/24.9cb11c3c.js"><link rel="prefetch" href="/assets/js/25.32b45cd3.js"><link rel="prefetch" href="/assets/js/26.cc84ad4e.js"><link rel="prefetch" href="/assets/js/27.97457ea0.js"><link rel="prefetch" href="/assets/js/28.0eba163c.js"><link rel="prefetch" href="/assets/js/29.8279803a.js"><link rel="prefetch" href="/assets/js/3.c62f26cc.js"><link rel="prefetch" href="/assets/js/30.4b073b21.js"><link rel="prefetch" href="/assets/js/31.8d171a47.js"><link rel="prefetch" href="/assets/js/32.ac67aeab.js"><link rel="prefetch" href="/assets/js/33.5a1ad04c.js"><link rel="prefetch" href="/assets/js/34.2ebf1c64.js"><link rel="prefetch" href="/assets/js/35.82e10b2f.js"><link rel="prefetch" href="/assets/js/36.df505946.js"><link rel="prefetch" href="/assets/js/37.947237c4.js"><link rel="prefetch" href="/assets/js/38.b112a159.js"><link rel="prefetch" href="/assets/js/39.00e0accc.js"><link rel="prefetch" href="/assets/js/4.17dc89f6.js"><link rel="prefetch" href="/assets/js/40.596390fb.js"><link rel="prefetch" href="/assets/js/41.fdd201e7.js"><link rel="prefetch" href="/assets/js/42.b9827e95.js"><link rel="prefetch" href="/assets/js/43.e2c31273.js"><link rel="prefetch" href="/assets/js/44.f88cec71.js"><link rel="prefetch" href="/assets/js/45.ba0933be.js"><link rel="prefetch" href="/assets/js/46.9dbce561.js"><link rel="prefetch" href="/assets/js/47.8cced2b5.js"><link rel="prefetch" href="/assets/js/5.43e33053.js"><link rel="prefetch" href="/assets/js/6.761b8afb.js"><link rel="prefetch" href="/assets/js/7.4a4f200a.js"><link rel="prefetch" href="/assets/js/8.b0c4b5ff.js"><link rel="prefetch" href="/assets/js/9.5f3a83a8.js">
    <link rel="stylesheet" href="/assets/css/0.styles.48f01dbf.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">a litter bug blog</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="https://github.com/vuejs/vuepress" target="_blank" rel="noopener noreferrer" class="nav-link external">
  github
  <svg xmlns="http://www.w3.org/2000/svg" aria-labelledby="outbound-link-title" role="img" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><title id="outbound-link-title">(opens new window)</title> <path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="https://github.com/vuejs/vuepress" target="_blank" rel="noopener noreferrer" class="nav-link external">
  github
  <svg xmlns="http://www.w3.org/2000/svg" aria-labelledby="outbound-link-title" role="img" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><title id="outbound-link-title">(opens new window)</title> <path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>Typescript入门</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><section class="sidebar-group collapsable is-sub-group depth-1"><a href="/typescript/Introduction/" class="sidebar-heading clickable"><span>介绍</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><a href="/typescript/Basic/" class="sidebar-heading clickable router-link-active open"><span>基础</span> <span class="arrow down"></span></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/typescript/Basic/basic-type.html" class="sidebar-link">基础类型</a></li><li><a href="/typescript/Basic/variable-declaration.html" class="sidebar-link">变量声明</a></li><li><a href="/typescript/Basic/interfaces.html" class="sidebar-link">接口</a></li><li><a href="/typescript/Basic/classes.html" class="sidebar-link">类</a></li><li><a href="/typescript/Basic/functions.html" class="sidebar-link">函数</a></li><li><a href="/typescript/Basic/literal-types.html" class="sidebar-link">字面量类型</a></li><li><a href="/typescript/Basic/generics.html" class="sidebar-link">泛型</a></li><li><a href="/typescript/Basic/enums.html" aria-current="page" class="active sidebar-link">枚举</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/typescript/Basic/enums.html#枚举-2" class="sidebar-link">枚举</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/typescript/Basic/enums.html#数字枚举" class="sidebar-link">数字枚举</a></li><li class="sidebar-sub-header"><a href="/typescript/Basic/enums.html#字符串枚举" class="sidebar-link">字符串枚举</a></li><li class="sidebar-sub-header"><a href="/typescript/Basic/enums.html#异构枚举-heterogeneous-enums" class="sidebar-link">异构枚举（Heterogeneous enums）</a></li><li class="sidebar-sub-header"><a href="/typescript/Basic/enums.html#计算的和常量成员" class="sidebar-link">计算的和常量成员</a></li><li class="sidebar-sub-header"><a href="/typescript/Basic/enums.html#联合枚举与枚举成员的类型" class="sidebar-link">联合枚举与枚举成员的类型</a></li><li class="sidebar-sub-header"><a href="/typescript/Basic/enums.html#运行时的枚举" class="sidebar-link">运行时的枚举</a></li><li class="sidebar-sub-header"><a href="/typescript/Basic/enums.html#编译时的枚举" class="sidebar-link">编译时的枚举</a></li></ul></li><li class="sidebar-sub-header"><a href="/typescript/Basic/enums.html#外部枚举" class="sidebar-link">外部枚举</a></li></ul></li><li><a href="/typescript/Basic/type-inference.html" class="sidebar-link">类型推论</a></li><li><a href="/typescript/Basic/type-compatibility.html" class="sidebar-link">类型兼容性</a></li><li><a href="/typescript/Basic/advanced-types.html" class="sidebar-link">高级类型</a></li><li><a href="/typescript/Basic/symbols.html" class="sidebar-link">Symbols</a></li><li><a href="/typescript/Basic/iterators-and-generators.html" class="sidebar-link">Iterators 和 Generators</a></li><li><a href="/typescript/Basic/modules.html" class="sidebar-link">模块</a></li><li><a href="/typescript/Basic/namespaces.html" class="sidebar-link">命名空间</a></li><li><a href="/typescript/Basic/namespaces-and-modules.html" class="sidebar-link">命名空间和模块</a></li><li><a href="/typescript/Basic/module-resolution.html" class="sidebar-link">模块解析</a></li><li><a href="/typescript/Basic/declaration-merging.html" class="sidebar-link">声明合并</a></li><li><a href="/typescript/Basic/jsx.html" class="sidebar-link">JSX</a></li><li><a href="/typescript/Basic/decorators.html" class="sidebar-link">Decorators</a></li><li><a href="/typescript/Basic/mixins.html" class="sidebar-link">混入</a></li><li><a href="/typescript/Basic/triple-slash-directives.html" class="sidebar-link">三斜线指令</a></li><li><a href="/typescript/Basic/type-checking-javascript-files.html" class="sidebar-link">JavaScript文件里的类型检查</a></li></ul></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><a href="/typescript/tsconfig.json/" class="sidebar-heading clickable"><span>工程配置</span> <span class="arrow right"></span></a> <!----></section></li><li><a href="/typescript/typescript-react/" class="sidebar-link">react-typescript</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="枚举"><a href="#枚举" class="header-anchor">#</a> 枚举</h1> <h2 id="枚举-2"><a href="#枚举-2" class="header-anchor">#</a> 枚举</h2> <p>使用枚举我们可以定义一些带名字的常量。 使用枚举可以清晰地表达意图或创建一组有区别的用例。 TypeScript支持数字的和基于字符串的枚举。</p> <h3 id="数字枚举"><a href="#数字枚举" class="header-anchor">#</a> 数字枚举</h3> <p>首先我们看看数字枚举，如果你使用过其它编程语言应该会很熟悉。</p> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">enum</span> Direction <span class="token punctuation">{</span>
    Up <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span>
    Down<span class="token punctuation">,</span>
    Left<span class="token punctuation">,</span>
    Right
<span class="token punctuation">}</span>
</code></pre></div><p>如上，我们定义了一个数字枚举，<code>Up</code>使用初始化为<code>1</code>。 其余的成员会从<code>1</code>开始自动增长。 换句话说，<code>Direction.Up</code>的值为<code>1</code>，<code>Down</code>为<code>2</code>，<code>Left</code>为<code>3</code>，<code>Right</code>为<code>4</code>。</p> <p>我们还可以完全不使用初始化器：</p> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">enum</span> Direction <span class="token punctuation">{</span>
    Up<span class="token punctuation">,</span>
    Down<span class="token punctuation">,</span>
    Left<span class="token punctuation">,</span>
    Right<span class="token punctuation">,</span>
<span class="token punctuation">}</span>
</code></pre></div><p>现在，<code>Up</code>的值为<code>0</code>，<code>Down</code>的值为<code>1</code>等等。 当我们不在乎成员的值的时候，这种自增长的行为是很有用处的，但是要注意每个枚举成员的值都是不同的。</p> <p>使用枚举很简单：通过枚举的属性来访问枚举成员，和枚举的名字来访问枚举类型：</p> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">enum</span> Response <span class="token punctuation">{</span>
    No <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>
    Yes <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">respond</span><span class="token punctuation">(</span>recipient<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span> message<span class="token operator">:</span> Response<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
<span class="token punctuation">}</span>

<span class="token function">respond</span><span class="token punctuation">(</span><span class="token string">&quot;Princess Caroline&quot;</span><span class="token punctuation">,</span> Response<span class="token punctuation">.</span>Yes<span class="token punctuation">)</span>
</code></pre></div><p>数字枚举可以被混入到<a href="/typescript/Basic/enums.html#computed-and-constant-members">计算过的和常量成员（如下所示）</a>。 简短地说，没有初始化器的成员要么在首位，要么必须在用数值常量或其他常量枚举成员初始化的数值枚举之后。 换句话说，下面的情况是不被允许的：</p> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">enum</span> <span class="token constant">E</span> <span class="token punctuation">{</span>
    <span class="token constant">A</span> <span class="token operator">=</span> <span class="token function">getSomeValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token constant">B</span><span class="token punctuation">,</span> <span class="token comment">// Error! Enum member must have initializer.</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="字符串枚举"><a href="#字符串枚举" class="header-anchor">#</a> 字符串枚举</h3> <p>字符串枚举的概念很简单，但是有细微的<a href="/typescript/Basic/enums.html#enums-at-runtime">运行时的差别</a>。 在一个字符串枚举里，每个成员都必须用字符串字面量，或另外一个字符串枚举成员进行初始化。</p> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">enum</span> Direction <span class="token punctuation">{</span>
    Up <span class="token operator">=</span> <span class="token string">&quot;UP&quot;</span><span class="token punctuation">,</span>
    Down <span class="token operator">=</span> <span class="token string">&quot;DOWN&quot;</span><span class="token punctuation">,</span>
    Left <span class="token operator">=</span> <span class="token string">&quot;LEFT&quot;</span><span class="token punctuation">,</span>
    Right <span class="token operator">=</span> <span class="token string">&quot;RIGHT&quot;</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>
</code></pre></div><p>由于字符串枚举没有自增长的行为，字符串枚举可以很好的序列化。 换句话说，如果你正在调试并且必须要读一个数字枚举的运行时的值，这个值通常是很难读的 - 它并不能表达有用的信息（尽管<a href="/typescript/Basic/enums.html#enums-at-runtime">反向映射</a>会有所帮助），字符串枚举允许你提供一个运行时有意义的并且可读的值，独立于枚举成员的名字。</p> <h3 id="异构枚举-heterogeneous-enums"><a href="#异构枚举-heterogeneous-enums" class="header-anchor">#</a> 异构枚举（Heterogeneous enums）</h3> <p>从技术的角度来说，枚举可以混合字符串和数字成员，但是似乎你并不会这么做：</p> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">enum</span> BooleanLikeHeterogeneousEnum <span class="token punctuation">{</span>
    No <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>
    Yes <span class="token operator">=</span> <span class="token string">&quot;YES&quot;</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>
</code></pre></div><p>除非你真的想要利用JavaScript运行时的行为，否则我们不建议这样做。</p> <h3 id="计算的和常量成员"><a href="#计算的和常量成员" class="header-anchor">#</a> 计算的和常量成员</h3> <p>每个枚举成员都带有一个值，它可以是_常量_或_计算出来的_。 当满足如下条件时，枚举成员被当作是常量：</p> <ul><li><p>它是枚举的第一个成员且没有初始化器，这种情况下它被赋予值<code>0</code>：</p> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token comment">// E.X is constant:</span>
<span class="token keyword">enum</span> <span class="token constant">E</span> <span class="token punctuation">{</span> <span class="token constant">X</span> <span class="token punctuation">}</span>
</code></pre></div></li> <li><p>它不带有初始化器且它之前的枚举成员是一个_数字_常量。 这种情况下，当前枚举成员的值为它上一个枚举成员的值加1。</p> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token comment">// All enum members in 'E1' and 'E2' are constant.</span>

<span class="token keyword">enum</span> <span class="token constant">E1</span> <span class="token punctuation">{</span> <span class="token constant">X</span><span class="token punctuation">,</span> <span class="token constant">Y</span><span class="token punctuation">,</span> <span class="token constant">Z</span> <span class="token punctuation">}</span>

<span class="token keyword">enum</span> <span class="token constant">E2</span> <span class="token punctuation">{</span>
    <span class="token constant">A</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token constant">B</span><span class="token punctuation">,</span> <span class="token constant">C</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li><p>枚举成员使用_常量枚举表达式_初始化。 常量枚举表达式是TypeScript表达式的子集，它可以在编译阶段求值。 当一个表达式满足下面条件之一时，它就是一个常量枚举表达式：</p> <ol><li>一个枚举表达式字面量（主要是字符串字面量或数字字面量）</li> <li>一个对之前定义的常量枚举成员的引用（可以是在不同的枚举类型中定义的）</li> <li>带括号的常量枚举表达式</li> <li>一元运算符<code>+</code>, <code>-</code>, <code>~</code>其中之一应用在了常量枚举表达式</li> <li>常量枚举表达式做为二元运算符<code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code>, <code>&lt;&lt;</code>, <code>&gt;&gt;</code>, <code>&gt;&gt;&gt;</code>, <code>&amp;</code>, <code>|</code>, <code>^</code>的操作对象。</li></ol> <p>若常量枚举表达式求值后为<code>NaN</code>或<code>Infinity</code>，则会在编译阶段报错。</p></li></ul> <p>所有其它情况的枚举成员被当作是需要计算得出的值。</p> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">enum</span> FileAccess <span class="token punctuation">{</span>
    <span class="token comment">// constant members</span>
    None<span class="token punctuation">,</span>
    Read    <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">,</span>
    Write   <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">2</span><span class="token punctuation">,</span>
    ReadWrite  <span class="token operator">=</span> Read <span class="token operator">|</span> Write<span class="token punctuation">,</span>
    <span class="token comment">// computed member</span>
    <span class="token constant">G</span> <span class="token operator">=</span> <span class="token string">&quot;123&quot;</span><span class="token punctuation">.</span>length
<span class="token punctuation">}</span>
</code></pre></div><h3 id="联合枚举与枚举成员的类型"><a href="#联合枚举与枚举成员的类型" class="header-anchor">#</a> 联合枚举与枚举成员的类型</h3> <p>存在一种特殊的非计算的常量枚举成员的子集：字面量枚举成员。 字面量枚举成员是指不带有初始值的常量枚举成员，或者是值被初始化为</p> <ul><li>任何字符串字面量（例如：<code>&quot;foo&quot;</code>，<code>&quot;bar&quot;</code>，<code>&quot;baz&quot;</code>）</li> <li>任何数字字面量（例如：<code>1</code>, <code>100</code>）</li> <li>应用了一元<code>-</code>符号的数字字面量（例如：<code>-1</code>, <code>-100</code>）</li></ul> <p>当所有枚举成员都拥有字面量枚举值时，它就带有了一种特殊的语义。</p> <p>首先，枚举成员成为了类型！ 例如，我们可以说某些成员_只能_是枚举成员的值：</p> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">enum</span> ShapeKind <span class="token punctuation">{</span>
    Circle<span class="token punctuation">,</span>
    Square<span class="token punctuation">,</span>
<span class="token punctuation">}</span>

<span class="token keyword">interface</span> <span class="token class-name">Circle</span> <span class="token punctuation">{</span>
    kind<span class="token operator">:</span> ShapeKind<span class="token punctuation">.</span>Circle<span class="token punctuation">;</span>
    radius<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">interface</span> <span class="token class-name">Square</span> <span class="token punctuation">{</span>
    kind<span class="token operator">:</span> ShapeKind<span class="token punctuation">.</span>Square<span class="token punctuation">;</span>
    sideLength<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> c<span class="token operator">:</span> Circle <span class="token operator">=</span> <span class="token punctuation">{</span>
    kind<span class="token operator">:</span> ShapeKind<span class="token punctuation">.</span>Square<span class="token punctuation">,</span> <span class="token comment">// Error! Type 'ShapeKind.Square' is not assignable to type 'ShapeKind.Circle'.</span>
    radius<span class="token operator">:</span> <span class="token number">100</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>
</code></pre></div><p>另一个变化是枚举类型本身变成了每个枚举成员的_联合_。 虽然我们还没有讨论<a href="/typescript/Basic/advanced-types.html#union-types">联合类型</a>，但你只要知道通过联合枚举，类型系统能够利用这样一个事实，它可以知道枚举里的值的集合。 因此，TypeScript能够捕获在比较值的时候犯的愚蠢的错误。 例如：</p> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">enum</span> <span class="token constant">E</span> <span class="token punctuation">{</span>
    Foo<span class="token punctuation">,</span>
    Bar<span class="token punctuation">,</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token constant">E</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">!==</span> <span class="token constant">E</span><span class="token punctuation">.</span>Foo <span class="token operator">||</span> x <span class="token operator">!==</span> <span class="token constant">E</span><span class="token punctuation">.</span>Bar<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">//             ~~~~~~~~~~~</span>
        <span class="token comment">// Error! This condition will always return 'true' since the types 'E.Foo' and 'E.Bar' have no overlap.</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这个例子里，我们先检查<code>x</code>是否不是<code>E.Foo</code>。 如果通过了这个检查，然后<code>||</code>会发生短路效果，<code>if</code>语句体里的内容会被执行。 然而，这个检查没有通过，那么<code>x</code>则_只能_为<code>E.Foo</code>，因此没理由再去检查它是否为<code>E.Bar</code>。</p> <h3 id="运行时的枚举"><a href="#运行时的枚举" class="header-anchor">#</a> 运行时的枚举</h3> <p>枚举是在运行时真正存在的对象。 例如下面的枚举：</p> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">enum</span> <span class="token constant">E</span> <span class="token punctuation">{</span>
    <span class="token constant">X</span><span class="token punctuation">,</span> <span class="token constant">Y</span><span class="token punctuation">,</span> <span class="token constant">Z</span>
<span class="token punctuation">}</span>
</code></pre></div><p>可以传递给函数</p> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span>obj<span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token constant">X</span><span class="token operator">:</span> <span class="token builtin">number</span> <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> obj<span class="token punctuation">.</span><span class="token constant">X</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 没问题，因为 'E'包含一个数值型属性'X'。</span>
<span class="token function">f</span><span class="token punctuation">(</span><span class="token constant">E</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="编译时的枚举"><a href="#编译时的枚举" class="header-anchor">#</a> 编译时的枚举</h3> <p>尽管一个枚举是在运行时真正存在的对象，但<code>keyof</code>关键字的行为与其作用在对象上时有所不同。应该使用<code>keyof typeof</code>来获取一个表示枚举里所有字符串<code>key</code>的类型。</p> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">enum</span> LogLevel <span class="token punctuation">{</span>
    <span class="token constant">ERROR</span><span class="token punctuation">,</span> <span class="token constant">WARN</span><span class="token punctuation">,</span> <span class="token constant">INFO</span><span class="token punctuation">,</span> <span class="token constant">DEBUG</span>
<span class="token punctuation">}</span>

<span class="token comment">/**
 * 等同于：
 * type LogLevelStrings = 'ERROR' | 'WARN' | 'INFO' | 'DEBUG';
 */</span>
<span class="token keyword">type</span> <span class="token class-name">LogLevelStrings</span> <span class="token operator">=</span> <span class="token keyword">keyof</span> <span class="token keyword">typeof</span> LogLevel<span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">printImportant</span><span class="token punctuation">(</span>key<span class="token operator">:</span> LogLevelStrings<span class="token punctuation">,</span> message<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> num <span class="token operator">=</span> LogLevel<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>num <span class="token operator">&lt;=</span> LogLevel<span class="token punctuation">.</span><span class="token constant">WARN</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Log level key is: '</span><span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Log level value is: '</span><span class="token punctuation">,</span> num<span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Log level message is: '</span><span class="token punctuation">,</span> message<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token function">printImportant</span><span class="token punctuation">(</span><span class="token string">'ERROR'</span><span class="token punctuation">,</span> <span class="token string">'This is a message'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h4 id="反向映射"><a href="#反向映射" class="header-anchor">#</a> 反向映射</h4> <p>除了创建一个以属性名做为对象成员的对象之外，数字枚举成员还具有了_反向映射_，从枚举值到枚举名字。 例如，在下面的例子中：</p> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">enum</span> Enum <span class="token punctuation">{</span>
    <span class="token constant">A</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> a <span class="token operator">=</span> Enum<span class="token punctuation">.</span><span class="token constant">A</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> nameOfA <span class="token operator">=</span> Enum<span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// &quot;A&quot;</span>
</code></pre></div><p>TypeScript可能会将这段代码编译为下面的JavaScript：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">var</span> Enum<span class="token punctuation">;</span>
<span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">Enum</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    Enum<span class="token punctuation">[</span>Enum<span class="token punctuation">[</span><span class="token string">&quot;A&quot;</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">&quot;A&quot;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span>Enum <span class="token operator">||</span> <span class="token punctuation">(</span>Enum <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> a <span class="token operator">=</span> Enum<span class="token punctuation">.</span><span class="token constant">A</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> nameOfA <span class="token operator">=</span> Enum<span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// &quot;A&quot;</span>
</code></pre></div><p>生成的代码中，枚举类型被编译成一个对象，它包含了正向映射（<code>name</code> -&gt; <code>value</code>）和反向映射（<code>value</code> -&gt; <code>name</code>）。 引用枚举成员总会生成为对属性访问并且永远也不会内联代码。</p> <p>要注意的是_不会_为字符串枚举成员生成反向映射。</p> <h4 id="const枚举"><a href="#const枚举" class="header-anchor">#</a> <code>const</code>枚举</h4> <p>大多数情况下，枚举是十分有效的方案。 然而在某些情况下需求很严格。 为了避免在额外生成的代码上的开销和额外的非直接的对枚举成员的访问，我们可以使用<code>const</code>枚举。 常量枚举通过在枚举上使用<code>const</code>修饰符来定义。</p> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">const</span> <span class="token keyword">enum</span> Enum <span class="token punctuation">{</span>
    <span class="token constant">A</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span>
    <span class="token constant">B</span> <span class="token operator">=</span> <span class="token constant">A</span> <span class="token operator">*</span> <span class="token number">2</span>
<span class="token punctuation">}</span>
</code></pre></div><p>常量枚举只能使用常量枚举表达式，并且不同于常规的枚举，它们在编译阶段会被删除。 常量枚举成员在使用的地方会被内联进来。 之所以可以这么做是因为，常量枚举不允许包含计算成员。</p> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">const</span> <span class="token keyword">enum</span> Directions <span class="token punctuation">{</span>
    Up<span class="token punctuation">,</span>
    Down<span class="token punctuation">,</span>
    Left<span class="token punctuation">,</span>
    Right
<span class="token punctuation">}</span>

<span class="token keyword">let</span> directions <span class="token operator">=</span> <span class="token punctuation">[</span>Directions<span class="token punctuation">.</span>Up<span class="token punctuation">,</span> Directions<span class="token punctuation">.</span>Down<span class="token punctuation">,</span> Directions<span class="token punctuation">.</span>Left<span class="token punctuation">,</span> Directions<span class="token punctuation">.</span>Right<span class="token punctuation">]</span>
</code></pre></div><p>生成后的代码为：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">var</span> directions <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span> <span class="token comment">/* Up */</span><span class="token punctuation">,</span> <span class="token number">1</span> <span class="token comment">/* Down */</span><span class="token punctuation">,</span> <span class="token number">2</span> <span class="token comment">/* Left */</span><span class="token punctuation">,</span> <span class="token number">3</span> <span class="token comment">/* Right */</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre></div><h2 id="外部枚举"><a href="#外部枚举" class="header-anchor">#</a> 外部枚举</h2> <p>外部枚举用来描述已经存在的枚举类型的形状。</p> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">declare</span> <span class="token keyword">enum</span> Enum <span class="token punctuation">{</span>
    <span class="token constant">A</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span>
    <span class="token constant">B</span><span class="token punctuation">,</span>
    <span class="token constant">C</span> <span class="token operator">=</span> <span class="token number">2</span>
<span class="token punctuation">}</span>
</code></pre></div><p>外部枚举和非外部枚举之间有一个重要的区别，在正常的枚举里，没有初始化方法的成员被当成常量成员。 对于非常量的外部枚举而言，没有初始化方法时被当做需要经过计算的。</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/typescript/Basic/generics.html" class="prev">
        泛型
      </a></span> <span class="next"><a href="/typescript/Basic/type-inference.html">
        类型推论
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.05721dd8.js" defer></script><script src="/assets/js/2.49c8bc2a.js" defer></script><script src="/assets/js/14.3bc65c2a.js" defer></script>
  </body>
</html>
